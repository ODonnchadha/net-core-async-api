## Building an Async API with ASP.NET Core
- by Kevin Dockx

- COURSE OVERVIEW:

- UNDERSTANDING THE POWER OF ASYNC:
  - Prerequisites & Tooling:
    - Visual Studio 2019. (Version 16.5 or better.)
    - Load testing: West Wind Websurge.
    - Introduction to the demo project.
  - Sync and Async Request Handling:
    - When? Performance is not the key benefit. Indirect performance benefits RE: concurrent requests.
    - The key benefit of writing async server-side code is increased scalability.
    - SCALABILITY: The capacity of a system, network, or process to handle a growing amount of work, or its potential to be enlarged to accommodate that growth.
    - Horizontal Scaling. Adding additional servers. (Or scaling out.)
      - RESTful systems are a good start. Other components can hurt scalability:
        - Non-distributed databases or caches.
    - Vertical Scaling:
      - Adding memory, storage, or increasing CPU. (Or scaling up.)
      - This is what Async code assists with. 
      - Writing an API in such a way that resource ultization is improved via vertical scalability at a server level.
    - Handling Synchronous Requests:
      - A thread from the thread pool. I/O call will block the thread. Unavailable for ther requests. Threads wait for calls to be complete.
    - Handling Asynchronous Requests:
      - A thread from the thread pool. I/O call will take time but thread returned to thread pool.   
  - I/O versus Computational Bound Work:
    - I/O: "Will my code be waiting for a task to be complete before continuing?"
    - File system, database, network calls. Server-side & client-side.
    - Computational: "Will my code be performing an expensive computation?"
    - Expensive business algorithm. Client-side.
    - NOTE: Don't use async on the server for  computation-bound work.
  - Multithreading, Concurrency, & Parallelism:
    - A thread is a basic unit of CPU utilization.
    - Multithreading: One single CPU or single core in a multi-core CPU can execute multiple threads concurrently.
    - Concurrency: A condition that exists when at least two threads are making progress.
    - Parallelism means that at least two threads are executing simultaneously. (Multi-core. Or hyper-threaded.)
  - Summary:
    - Use async on the server to increase scalability.
    - The thread that is handling an async request is freed up to handle other requests.
    - It does not wait idly for I/O operations to complete.
    - Use async on the server for I/O-bound work. e.g.: File system, netwrok, database requests.
    - Do not use async on the server for computational work. e.g.: long-running calculations. May have adverse effects.
    - Can be used on the client.
  
- STARTING AT THE BOTTOM WITH YOUR DATA ACCESS LAYER:
  - Keywords async & await.
    - Marking a method with the async modifier.
      - Ensures that the await keyword can be used inside that method.
      - Transforms the method into a state machine. (Generated  by the compiler.)
    - Using the await operator:
      - Tells the compiler that the async method can't continue until the awaited asynchronous process is complete.
      - Returns control to the caller of the async method (potentially right back up to the thread being freed.)
    - NOTE: A method that is not marked with the async modifier cannot be awaited.
    - NOTE: When an async method doesn't contain an await operator the method simply executes as a synchronous method does.
    - Async method return types:
      - void. Task. Task<T>. (C# 7: Types with accessable GetAwaiter methods.)
      - void: Only advised for event handlers. Hard to handle exceptions. 
      - Difficult to test. No easy manner in which to notify the calling code of a status.
      - Task & Task<T>: 
        - Represents a single operation that returns nothing (Task) or a vakue of type T (Task<T> and usually executes asynchronously.)
        - Represents the execution of the async method. Not the result of the async method.
        - Status, IsCanceled, IsCompleted, and IsFaulted properties allow determining the state of a Task.
        - Through Task & Task<T> we can know the state of an async operation.
        - Tasks are managed by the state machine generated by the compiler when a method is marked with the async modifier.
        - Types with an accessable GetAwaiter method. Implements the System.Runtime.CompilerServices.ICriticalNotifyCompletion interface.
        - NOTE: Using reference types can induce memory allocation in performance-critical paths, and that can adversly affect performance.
        - Supporting generalized return types allows returning a lightweight value type.
  - Async Patterns: TAP, EAP, & APM:
    - Task-based Asynchronous Pattern:
      - Best practice today. Based upon Task, Task<T>, GetAwaiter() - implementing types.
    - Event-based Asynchronous Pattern:
      - Multithreading without complexity. MenthodNameAsync (method.) MethodNameCompleted (event.) MethodNameAsyncCancelled (method.)
      - Mainly used prior to .NET 4.
    - Asychronous Programming Model:
      - Async operations are implemented as two methods named BeginOperationName & EndOperationName.
      - e.g.: FileStream class used to default to this model. Replaced by TAP.
  - The purpose of Task & Task<T>.
  - DAL & Repository.
    - Repository Pattern:
      - Assists in avoiding: code duplication. error-prone code. tough testing.
      - An abstraction that reduces complexity and aims to make the code, safe for the repository implementation, persistence ignorant.
  - Naming guidelines, conventions, and best practices.
    - Contracts and Async Modifiers:
      - An interface is a contract, which makes the GetBooksAsync() defination a contract detail.
      - Using the async/await keywords inform us as to how the method is implemented, which makes it an implementation detail.
  - Summary:
    - Marking a mthod with the async modifier:
      - Ensures that the await keyword can be used inside that method. Transforms the mothos into a state machine.
    - Using the await operator:
      - Tells the compiler that the async method can't continue until the awaited asynchronous process is complete.
      - Returns control to the caller of the async method.
    - A Task:
      - Represents a single operation that returns nothing (Task) or a value of type T (Task<T>).
      - Represents the execution of the async method.
  
- ASYNCHRONOUSLY READING RESOURCES:
  - Adding an async controller action:
    - [ApiController()] forces the use of attribute-based routing, which is the best practice when building ASP.NET APIs.
    - Convention-based routing is more for MVC-based applications.
      ```csharp
        [ApiController()]
        [Route("api/books")]
        public class BooksController : ControllerBase
        {
      ```
  - Testing async code improvements: Introducing WebSurge:
    - Scalability improvements: Load testing. Combined with thread pool throttling.
    - WebSurge is a free tool specifically aimed at load testing.
    - TODO: Allow for 0.02 seconds delay to represent SQL Server on a DB Server and not local.
        ```csharp
            context.Database.ExecuteSqlCommand();
        ```
    - The outer-facing model:
        - Entity model: Entity classes represent (partial) database rows as objects.
        - Outer-facing Model: DTO classes represent resources that are sent over the wire.
        How do we represent the resource data type?
            - Model classes, DTOs, statically-typed approach.
            - Dynamics, anonymous objects, ExpandoObjects.
            - We can avoid mapping code in controller actions by leveraging a reuseable IAsyncResultFilter.
  - Using an AsyncResultFilter:
    - Manipulating output with an AsyncResultFilter:
    - Filters in ASP.NET Cover MVC allow us to run code before or after specific stages in the request processing pipeline.
    - Each delegate performs a next(); within the pipeline.
    - MVC is also a piece of middleware within the pipeline.
    - Filters run within the MVC action invocation pipeline (aka filter pipeline.)
        1. Authorization filters.
        2. Resource filters.
        3. Model binding.
        4. Action filters.
        5. !Action executes.
        6. Exception filters.
        7. Result filters.
        8. !Result executes.
    - By using result filters we can keep our actions cleaner and promote reuse.
    - IResultFilter, IAsyncResultFilter interfaces.
        - ResultFilterAttribute (abstract.)
    - Summary:
        - Async code has a tendency to bubble up application layers due to compiler errors and warnings.
        - Can't await if the calling method isn't marked with the async modifier.
        - Keep models seperate. Mixing models & responsibilities between layers leads to evolvability issues.
        - Result filters run right before and after the result is executed.
            - Makes them a good location for mapping code. Makes the mapping code reuseable.

- ASYNCHRONOUSLY MANIPULATING RESOURCES:
    - When to go async? AddAsync() within a context is used to allow special value generators.
    - For all other cases, the non async method should be used. Why?
    - Bulk Inserts: Ten books per:
        - Overhead. Performance loss. Overuse of threads (Scalability suffers.)
    - Supporting bulk inserts: POST api/bookcollections
    - Alternate approach:
        - /bulk endpoint supporting a collection of resources.
        - A set of resources and operations on the resources.
    - Summary:
        - Use Async for I/O bound work.
        - Adding an entity to the context isn't I/O bound work.
        - Bulk inserts can help with scalability.

- UNDERSTANDING HOW TO INTEGRATE WITH EXTERNAL SERVICES USING ASYNC:
    - Asynchronously calling an external service.
    - Waiting for multiple tasks to complete.
    - Cancelling tasks.
    - Gracefully handle exceptions.
    - Why cancellation matters:
        - Frees up threads (I/O-bound work.) Improves scalability.
        - Frees up CPU resources (computational bound work.)
    - Summary:
        - Execute multiple tasks in order by awaiting them. Tasks are returned in order.
        - Use Task.WhenAll() or Task.WghenAny() when executing multiple tasks in parallel.
        - Task results are returned when the task in completed.
        - Cancel tasks to free up threads.
        - CancellationTokenSource & CancellationToken
        - Handle a cancellation exception by catchingit as an OperationCancelledException, which exposes the CancellationToken.

- AVOIDING COMMON PITFALLS:
    - Wrapping legacy code. Offloading legacy code to a background thread.
        - Long-running algorithms is computational-bound code.
        - These can be offloaded to a background thread using async/await. Can run concurrently.
    - Blocking async code.
    - Modifying shared state.
    - PITFALL #1: Using Task.Run() on the server:
        - Threads are switched. The initial wrapper await is returned to the thread pool.
        - Task.Run() on the server decreases scalability.
        - It's intended for use on the client (e.g.: to keep the UI responsive.)
    - PITFALL #2: Blocking Async Code:
        - Task.Wait() and Task.Result() block the calling thread.
            - Thread is not returned to the thread pool. Blocking code hurts scalability.
        - NOTE: ASP.NET Core does not have a synchronization context (The older ASP.NET does.)
            - The improves performance. We do not need to synchronize between contexts anymore.
            - Makes it easier to write async code.
    - PITFALL #3: Modifying Shared State:
        - Different threads might manipulate the same state at the same time.
            - Correctness cannot be guarenteed.
    - Summary:
        - Three common pitfalls.
            1. Don't use Task.Run() on the server. This hurts scalability.
            2. Don't block async code. This hurts scalability.
            3. Don't modify shared state. State cannot be guarenteed.