## Building an Async API with ASP.NET Core
- by Kevin Dockx

- COURSE OVERVIEW:

- UNDERSTANDING THE POWER OF ASYNC:
  - Prerequisites & Tooling:
    - Visual Studio 2019. (Version 16.5 or better.)
    - Load testing: West Wind Websurge.
    - Introduction to the demo project.
  - Sync and Async Request Handling:
    - When? Performance is not the key benefit. Indirect performance benefits RE: concurrent requests.
    - The key benefit of writing async server-side code is increased scalability.
    - SCALABILITY: The capacity of a system, network, or process to handle a growing amount of work, or its potential to be enlarged to accommodate that growth.
    - Horizontal Scaling. Adding additional servers. (Or scaling out.)
      - RESTful systems are a good start. Other components can hurt scalability:
        - Non-distributed databases or caches.
    - Vertical Scaling:
      - Adding memory, storage, or increasing CPU. (Or scaling up.)
      - This is what Async code assists with. 
      - Writing an API in such a way that resource ultization is improved via vertical scalability at a server level.
    - Handling Synchronous Requests:
      - A thread from the thread pool. I/O call will block the thread. Unavailable for ther requests. Threads wait for calls to be complete.
    - Handling Asynchronous Requests:
      - A thread from the thread pool. I/O call will take time but thread returned to thread pool.   
  - I/O versus Computational Bound Work:
    - I/O: "Will my code be waiting for a task to be complete before continuing?"
    - File system, database, network calls. Server-side & client-side.
    - Computational: "Will my code be performing an expensive computation?"
    - Expensive business algorithm. Client-side.
    - NOTE: Don't use async on the server for  computation-bound work.
  - Multithreading, Concurrency, & Parallelism:
    - A thread is a basic unit of CPU utilization.
    - Multithreading: One single CPU or single core in a multi-core CPU can execute multiple threads concurrently.
    - Concurrency: A condition that exists when at least two threads are making progress.
    - Parallelism means that at least two threads are executing simultaneously. (Multi-core. Or hyper-threaded.)
  - Summary:
    - Use async on the server to increase scalability.
    - The thread that is handling an async request is freed up to handle other requests.
    - It does not wait idly for I/O operations to complete.
    - Use async on the server for I/O-bound work. e.g.: File system, netwrok, database requests.
    - Do not use async on the server for computational work. e.g.: long-running calculations. May have adverse effects.
    - Can be used on the client.
  
- STARTING AT THE BOTTOM WITH YOUR DATA ACCESS LAYER:
  - Keywords async & await.
    - Marking a method with the async modifier.
      - Ensures that the await keyword can be used inside that method.
      - Transforms the method into a state machine. (Generated  by the compiler.)
    - Using the await operator:
      - Tells the compiler that the async method can't continue until the awaited asynchronous process is complete.
      - Returns control to the caller of the async method (potentially right back up to the thread being freed.)
    - NOTE: A method that is not marked with the async modifier cannot be awaited.
    - NOTE: When an async method doesn't contain an await operator the method simply executes as a synchronous method does.
    - Async method return types:
      - void. Task. Task<T>. (C# 7: Types with accessable GetAwaiter methods.)
      - void: Only advised for event handlers. Hard to handle exceptions. 
      - Difficult to test. No easy manner in which to notify the calling code of a status.
      - Task & Task<T>: 
        - Represents a single operation that returns nothing (Task) or a vakue of type T (Task<T> and usually executes asynchronously.)
        - Represents the execution of the async method. Not the result of the async method.
        - Status, IsCanceled, IsCompleted, and IsFaulted properties allow determining the state of a Task.
        - Through Task & Task<T> we can know the state of an async operation.
        - Tasks are managed by the state machine generated by the compiler when a method is marked with the async modifier.
        - Types with an accessable GetAwaiter method. Implements the System.Runtime.CompilerServices.ICriticalNotifyCompletion interface.
        - NOTE: Using reference types can induce memory allocation in performance-critical paths, and that can adversly affect performance.
        - Supporting generalized return types allows returning a lightweight value type.
  - Async Patterns: TAP, EAP, & APM:
    - Task-based Asynchronous Pattern:
      - Best practice today. Based upon Task, Task<T>, GetAwaiter() - implementing types.
    - Event-based Asynchronous Pattern:
      - Multithreading without complexity. MenthodNameAsync (method.) MethodNameCompleted (event.) MethodNameAsyncCancelled (method.)
      - Mainly used prior to .NET 4.
    - Asychronous Programming Model:
      - Async operations are implemented as two methods named BeginOperationName & EndOperationName.
      - e.g.: FileStream class used to default to this model. Replaced by TAP.
  - The purpose of Task & Task<T>.
  - DAL & Repository.
  - Naming guidelines, conventions, and best practices.